import math
import sys
source = sys.argv[1]
destination = sys.argv[2]
routing_option = sys.argv[3]
city=  [[y for index, y in enumerate(x.strip().split(" ")) if y] for x in open("./ex.txt") if x.strip() != ""]
city_arr={}
# a dictionary where key is the name of city and value is a tuple of latitude and longitude
[city_arr.update({str(x[0]):(float(x[1]),float(x[2]))}) for x in city]
# a list of road segments. [city1, city2, length, spdlimit, segment name]
road_seg = [[y for index, y in enumerate(x.strip().split(" ")) if y] for x in open("./ex2") if x.strip() != ""]
list_of_cities=[]
for row in road_seg:
	list_of_cities.append(row[0])
	list_of_cities.append(row[1])
list_of_cities = list(set(list_of_cities))
#a dictionary storing adjacent cities for a given city. the "city" can also be a highway which is connected using another highway
def adjacent_cities(adj_city):
	adjacency_dict={}
	for city in list_of_cities:
		adj_list=filter(None, [(row[1],row[2],row[3],row[4]) if row[0]==city else (row[0],row[2],row[3],row[4]) if row[1]==city else None for row in road_seg])
		adjacency_dict.update({city: adj_list})
	return adjacency_dict.get(adj_city)
#Displacement : haversine distance between two cities used as heuristic function.
def displacement(city_one, city_two):
	lat_city_one, lon_city_one, lat_city_two, lon_city_two = map(math.radians, [city_arr.get(city_one)[0], city_arr.get(city_one)[1], city_arr.get(city_two)[0], city_arr.get(city_two)[1]])
	latDist, lonDist= lat_city_two-lat_city_one, lon_city_two-lon_city_one	
	x=math.sin(latDist/2)**2 + math.cos(lat_city_one) * math.cos(lat_city_two) * math.sin(lonDist/2)**2
	return 6371*2*math.asin(math.sqrt(x))
#Define goal state
def is_goal(place):
	return True if place== destination else False
#successor cities
def successors(city):
	if routing_option == "distance":
		return sorted([(x[0],float(x[1])) for x in adjacent_cities(city)],  key = lambda tuple: tuple[1])
	elif routing_option == "time":
		return sorted([(x[0],float(x[1])/float(x[2])) for x in adjacent_cities(city)], key = lambda tuple: tuple[1])
	elif routing_option == "scenic":
		print [x[2] for x in adjacent_cities(city)]
		return sorted( [(x[0],0) if x[2]<55  for x in adjacent_cities(city)], key = lambda tuple: tuple[1])
	elif routing_option == "segments":
		 return [(x[0],1) for x in adjacent_cities(city)]

#bfs
def find_route(source, destination):
	current_place = [source]
	route = [source]
	while current_place!= destination:
		for s in successors(current_place.pop()[0]):
			if s!=None:
				if is_goal(s):
					route.append(s)
					return route
				current_place.append(s)
				
  	print route
	return False

print successors(source)
print adjacent_cities(source)	
